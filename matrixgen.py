import numpy as np
import os,sys

# -------------------------------------------------- #
# README
# -------------------------------------------------- #
# Author: Karl Young
# Date: Dec.19 2019
# Assignment: Group Project for Anna Ritz & Computational Systems Biology
#
# Code for generating NMII regulatory predictions based on protein interactions and
# labeled proteins. This module will generate data that is used by distributiongen.py
# to actually generate the predictions. The user needs to enter a value LAMBDA (the meaning of
# which can be found in the next section), which is baked into the data generated by this file. 
# The code will generate a Directory based on the lambda value, and three data files. For 
# example, for a value of LAMBDA = 0.1, the code will generate a directory L0.1/ and the files
# L0.1/labels.txt, L0.1/matrix.npy, L0.1/cvector.npy. Giving the same LAMBDA to the module 
# distributiongen.py will look in that directory, perform the matrix multiplication and output 
# the top 50 gene predictions.
# 
# I played around a little bit with command line interface stuff for entering these
# values, but it got a little unwieldy and I didn't want to comment that code so
# as of right now the values have to be hard coded. 
#
# To run: set paths to protein interaction networks and label files, and a specific LAMBDA.
PPINPATH = './data/interactome-flybase-collapsed-weighted.txt'
LABLPATH = './data/labeled_nodes.txt'
LAMBDA = 0.155

# -------------------------------------------------- #
# MATH
# -------------------------------------------------- #
# This is all adapted from 
#
# Bern, M., King, A., Applewhite, D. A., & Ritz, A. (2019). 
# Network-based prediction of polygenic disease genes involved in cell motility. 
# BMC Bioinformatics, 20(S12), 313. https://doi.org/10.1186/s12859-019-2834-1
#
# whose explanations might be clearer due to the ability to typeset symbols :).
#
# The goal is to assign each node in the graph a value between 0 and 1, with positively 
# labeled nodes always given a 1. Then we'd like the values to be smooth, i.e. the closer
# two nodes are, the closer their values should be. From a mathematical standpoint then,
# we just need each node to have a value that is the average of its neighbors. To do this,
# we just pick some arbitrary initial distribution and iteratively calculate the average
# of each nodes neighbors until the system converges. However, if we left the system
# unhindered, each node would converge to a value of 1, so we need to apply some kind of
# 'negative pressure' to the graph as a whole. The strength of this pressure is quantified
# by the LAMBDA parameter, and a formal description is available in the above paper.
#
# At this level, the unlabeled distribution is modeled as a vector, with contributions
# from neighboring unlabeled nodes represented as a matrix and contributions from
# labeled nodes represented as a constant vector. This code below generates the
# matrix and constant vector for a given lambda, where lambda represents the strength
# of negative feedback to all nodes.


def edge(u,v):
    # this is a goofy little function cause I got sick of writing
    # frozenset(('node1','node2')) all the time to refrence the
    # edgelist. this saves typing and I think looks nicer. also
    # keeps the benefit of edge(u,v) = edge(v,u). very handy
    return frozenset((u,v))

def readedgefile(filename):
    # this function returns a dictionary, where the keys are edges and the values are
    # edge weights. to make sure (u,v) and (v,u) are the same (undirected graph!!), the
    # underlying representation is frozen sets. but I hate seeing/typing that word out
    # so threw the above edge function to hide that. anyway.
    with open(filename) as f:
        next(f)
        return {edge(l[0],l[1]):float(l[2]) for l in (line.split() for line in f)}

def readpositives(filename):
    # this bad boy just gives back a set of nodes that are labeled Positive in the
    # labels file.
    with open(filename) as f:
        next(f)
        return {line[0] for line in (l.split() for l in f) if line[2] == 'Positive'}

def makeadjlist(edgelist):
    # so this was a little different from my usual setup, but the keys are nodes, and
    # the values are neighbor dictionaries. the neighbor dictionaries have as their keys
    # neighbors to the original node and values weights of the edge from the og node to the
    # neighbor, if that makes sense. so for instance
    # {
    # A:{B:4,C:6},
    # B:{A:4},
    # C:{A:6}
    # }
    # means that A is connected to B and C with weights 4 and 6.
    adjlist = {}
    for (u,v),w in edgelist.items():
        if u not in adjlist:
            adjlist[u] = {}
        if v not in adjlist:
            adjlist[v] = {}
        adjlist[u][v] = w
        adjlist[v][u] = w
    return adjlist

def getsmooth(edgelist,adjlist,positives,LAMBDA):
    # Inputs: a set of edges, an adjacency list, a set of labeled positives, and a LAMBDA
    # Outputs: a matrix representing how the unlabeled proteins affect one another's final
    #           value, a vector representing the how the labeled nodes affect the unlabeled
    #           nodes final distribution, and a set of the unlabeled nodes so we can later
    #           read them in the same order as are represented in the matrix.

    # creates a dictionary of node:weighted_degree, just so we don't have to keep calculating
    weightsd = {node:sum(neighbord.values()) for node,neighbord in adjlist.items()}

    # now we're creating the set of unlabeled nodes (the only ones we actually need to calculte)
    # and also associating each node with an index into the final distribution vector.
    unlabeled = set(adjlist) - positives
    indexdict = {node:i for i,node in enumerate(unlabeled)}

    # Since f_t represents only unlabeled nodes, the size of M and c depend only on the size of 
    # the unlabeled set.
    ndim = len(unlabeled)
    matrix = np.zeros((ndim,ndim))
    cvector = np.zeros(ndim)

    # M is defined by M_uv = w(u,v)/d_u + lambda, where w(u,v) = weight of the edge between u + v,
    # and d_u is the weighted degree of u.
    for rnode in unlabeled:
        # ------- BUILDING M ------- #
        for cnode in unlabeled:
            # need check if the edge exists, otherwise edgeweight lookup throws keyerror
            # if it doesn't exist, matrix entry should be 0 anyway.
            if edge(rnode,cnode) in edgelist:
                # uses the indexdict to index into the numpy array.
                matrix[indexdict[rnode],indexdict[cnode]] = edgelist[edge(rnode,cnode)]/(weightsd[rnode] + LAMBDA)

        # ------- BUILDING c ------- #
        # finds nodes that are positives and neighbors of the current node, weights their
        # contributions based on edge weights, and sets the value for c.
        #!!!! if one were inclined, weightedpos = len(posneighbors) !!!!#
        posneighbors = set(adjlist[rnode]).intersection(positives)
        weightedpos = sum([edgelist[edge(pn,rnode)] for pn in posneighbors])
        cvector[indexdict[rnode]] = weightedpos/(weightsd[rnode] + LAMBDA)

    return(matrix,cvector,unlabeled)
    
def main():
    try:
        assert os.path.exists(PPINPATH)
        assert os.path.exists(LABLPATH)
    except:
        print("Can't find PPI data!")
        sys.exit()
    # Checks really quick to see if data has already been generated.
    directory = 'L%g'%LAMBDA
    try:
        assert not os.path.exists(directory)
    except:
        print('Data already exists homie!')
        sys.exit()

    # If not, make the directory to store files in.
    os.mkdir(directory)


    # generates edgelist(dict of edge:weight)
    # generates set of labeled positives
    # generates adjlist(dict of node:neighbordict)
    edgelist = readedgefile(PPINPATH)
    positives = readpositives(LABLPATH)
    adjlist = makeadjlist(edgelist)

    # the longest part of the process, generates the matrix M, vector c, and
    # the set of unlabeled nodes. 
    matrix,cvector,unlabeled = getsmooth(edgelist,adjlist,positives,LAMBDA)
    
    # to save on time a little and allow us to easily play with different iterations
    # i save all of the data to a file. hope the labels are clear enough.
    labelfile = directory+'/labels.txt'
    matrixfile = directory+'/matrix'
    cvectorfile = directory+'/cvector'
    with open(labelfile,'w') as f:
        [f.write(node+'\n') for node in unlabeled]
    np.save(matrixfile,matrix)
    np.save(cvectorfile,cvector)

    print('Wrote to %s!'%directory)
    

if __name__ == '__main__':
    main()    
